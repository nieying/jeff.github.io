{"meta":{"title":"长不大的孩子","subtitle":null,"description":"null==undefined","author":"jeff","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-03-12T09:48:53.000Z","updated":"2018-03-21T02:05:25.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-12T09:50:47.000Z","updated":"2018-03-21T02:05:15.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-13T06:19:11.000Z","updated":"2018-03-21T02:05:02.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-生命周期函数","slug":"react-生命周期函数","date":"2018-05-09T05:47:14.000Z","updated":"2018-05-09T06:33:34.000Z","comments":true,"path":"2018/05/09/react-生命周期函数/","link":"","permalink":"http://yoursite.com/2018/05/09/react-生命周期函数/","excerpt":"","text":"组件的生命周期可分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM componentWillMount在渲染前调用，在客户端也在服务端 componentDidMount在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 componentWillReceiveProps在组建接收到一个新的props（跟新后）调用。在初始化render的时候不会被调用 shouldComponentUpdate返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount在组件从DOM中移除的时刻立即被调用 下面是一个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Button = React.createClass(&#123; getInitialState: function() &#123; return &#123; data:0 &#125;; &#125;, setNewNumber: function() &#123; this.setState(&#123;data: this.state.data + 1&#125;) &#125;, render: function () &#123; return ( &lt;div&gt; &lt;button onClick = &#123;this.setNewNumber&#125;&gt;INCREMENT&lt;/button&gt; &lt;Content myNumber = &#123;this.state.data&#125;&gt;&lt;/Content&gt; &lt;/div&gt; ); &#125;&#125;)var Content = React.createClass(&#123; componentWillMount() &#123; console.log('Component WILL MOUNT!') &#125;, componentDidMount() &#123; console.log('Component DID MOUNT!') &#125;, componentWillReceiveProps(newProps) &#123; console.log('Component WILL RECEIVE PROPS!') &#125;, shouldComponentUpdate(newProps, newState) &#123; return true; &#125;, componentWillUpdate(nextProps, nextState) &#123; console.log('Component WILL UPDATE!'); &#125;, componentDidUpdate(prevProps, prevState) &#123; console.log('Component DID UPDATE!') &#125;, componentWillUnmount() &#123; console.log('Component WILL UNMOUNT!') &#125;, render: function () &#123; return ( &lt;div&gt; &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;div&gt; &lt;Button /&gt; &lt;/div&gt;, document.getElementById('example'));","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-redux简单用法","slug":"react-redux简单用法","date":"2018-05-08T07:43:49.000Z","updated":"2018-05-08T08:24:01.964Z","comments":true,"path":"2018/05/08/react-redux简单用法/","link":"","permalink":"http://yoursite.com/2018/05/08/react-redux简单用法/","excerpt":"","text":"React-redux简介React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 UI组件 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 容器组件 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API connect就是把UI组件和容器组件连接起来 mapStateToPropsmapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。12345const mapStateToProps = (state) =&gt; &#123; return &#123; userInfo: state.global.userInfo &#125;&#125; 使用redux无论代码怎么布局，使用redux的方法主要还是三步曲：创建store、创建action、创建reducer。而在这之后才是与业务或者组件相关的数据处理和展示。 App.js // 入口文件 123456789101112131415161718import React from 'react';import ReactDOM from 'react-dom';import &#123; createStore, applyMiddleware, combineReducers &#125; from 'redux';import thunk form 'redux-thunk';import &#123; Provider &#125; from 'react-redux'import rootReducer from '../../index'const store = createStore( combineReducers(&#123; ...rootReducer &#125;), applyMiddleware(thunk));ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;div &#123;this.props&#125; /&gt; &lt;/Provider&gt; , document.getElementById('root')) index.js // 所有的reducer入口 1234567import &#123;global&#125; from './global'const rootReducer = &#123; global&#125;export default rootReducer action 1234export const saveUserInfo = userInfo =&gt; (&#123; type:'SAVE_USER_INFO', userInfo&#125;) reducers 12345678910111213export const global = (state, action) =&gt; &#123; switch(action.type) &#123; case 'SAVE_USER_INFO': return &#123; ...state, userInfo: action.userInfo &#125;; default: return state; &#125;&#125; 组件中使用 123456789101112131415161718import &#123; connent &#125; from 'redux'import &#123; saveUserInfo &#125; from '../action.js'class Login extends Component &#123; onClickCallback = () =&gt; &#123; this.props.dispath(saveUserInfo(data)) // 触发action &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; userInfo: state.global.userInfo &#125;&#125;export default connect(mapStateToProps)(Login)","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-ref用法","slug":"react-ref用法","date":"2018-05-08T07:29:54.000Z","updated":"2018-05-08T07:39:34.000Z","comments":true,"path":"2018/05/08/react-ref用法/","link":"","permalink":"http://yoursite.com/2018/05/08/react-ref用法/","excerpt":"","text":"ref定义ref顾名思义我们知道，其实它就可以被看座是一个组件的参考，也可以说是一个标识。作为组件的属性，其属性值可以是一个字符串也可以是一个函数。 ref使用场景父类调用子类的方法 1234567891011121314151617181920212223242526class Parents extends Component &#123; sayHello = () =&gt; &#123; this.refs.fun() // 调用子类方法 &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.sayHello&#125;&gt;click me&lt;/button&gt; &lt;Childs ref=&#123;(ref) =&gt; &#123;this.refs = ref;&#125;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;class Childs extends Component &#123; fun = () =&gt; &#123; console.log('hello boys') &#125; render () &#123; return ( &lt;div&gt; hello &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"vue-router-导航钩子","slug":"vue-router-导航钩子","date":"2018-05-07T06:13:44.000Z","updated":"2018-05-07T06:37:05.893Z","comments":true,"path":"2018/05/07/vue-router-导航钩子/","link":"","permalink":"http://yoursite.com/2018/05/07/vue-router-导航钩子/","excerpt":"","text":"全局钩子123456789101112// 定义一个路由const router = new VueRouter(&#123;&#125;)// 点击路由前调用router.beforeEach((to, from, next) =&gt; &#123; // todo&#125;)// 点击路由后调用router.afterEach((to, from , next) =&gt; &#123; // tood&#125;) to 即将进入的目标，路有对象 from 当前正要离开的路由 next Function 一定要调用该方法来resolve这个钩子，执行效果依赖next方法的调用参数 单个路由独享的钩子1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/test', component: Test, beforeEnter: (to, from, next) =&gt; &#123; // todo &#125;, beforeEnter: (route) =&gt; &#123; // todo &#125; &#125; ]&#125;); 组件内的钩子123456789101112131415const Foo = &#123; tempalte: `...`, beforeRouteEnter(to, from , next) &#123; // 不能访问组件实例 `this`, 因为在这个时候组件还没被创建，但是可以通过 `next` 来访问 next (vm = &gt; &#123; // 通过 `vm` 访问组件实例 &#125;) &#125;, beforeRouteUpdate(to, from , next) &#123; // todo &#125;, beforeRouteLeave(to, from , next) &#123; // todo &#125;,&#125;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"react监听路有变化","slug":"react监听路有变化","date":"2018-03-30T01:09:33.000Z","updated":"2018-05-07T06:14:50.542Z","comments":true,"path":"2018/03/30/react监听路有变化/","link":"","permalink":"http://yoursite.com/2018/03/30/react监听路有变化/","excerpt":"","text":"12345678910111213141516171819202122import React , &#123; Component &#125; from 'react';import creactHistory from 'history/createHashHistory'const history = createHistory();clase Demo extends Component &#123; componentDidMount() &#123; this.listenHistory() &#125; listenHistory = () =&gt; &#123; history.listen((location) =&gt; &#123; // todo something &#125;) &#125;&#125;;export default Demo;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react定时器","slug":"react定时器","date":"2018-03-22T09:16:02.000Z","updated":"2018-05-07T06:15:27.000Z","comments":true,"path":"2018/03/22/react定时器/","link":"","permalink":"http://yoursite.com/2018/03/22/react定时器/","excerpt":"","text":"123456789101112131415import React , &#123; Component &#125; from 'react';clase Demo extends Component &#123; hanldClick = () =&gt; &#123; this.timer &amp;&amp; clearInterval(this.timer) this.timer = setInterval(() =&gt; &#123; // todo something &#125;, 1000) &#125; &#125;;export default Demo;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react如何实现双向绑定的？","slug":"react如何实现双向绑定的？","date":"2018-03-21T02:31:30.000Z","updated":"2018-05-07T06:15:12.605Z","comments":true,"path":"2018/03/21/react如何实现双向绑定的？/","link":"","permalink":"http://yoursite.com/2018/03/21/react如何实现双向绑定的？/","excerpt":"","text":"大家都知道react是单向数据流的，那我们怎么实现数据双向绑定的呢？ 12345678910111213141516171819202122232425import React , &#123; Component &#125; from 'react';clase Demo extends Component &#123; state = &#123; txt: 'hello man' &#125; handChange = (e) =&gt; &#123; console.log(e.target) this.setState(&#123;txt: e.target.value&#125;) // todo something &#125; render() &#123; const &#123; txt &#125; = this.state; return ( &lt;input type=\"text\" value=&#123;txt&#125; onChange=&#123;this.handChange&#125;/&gt; &lt;p&gt;&#123;txt&#125;&lt;/p&gt; ) &#125;&#125;;export default Demo; 记住在react中改变state中值，千万不要直接 this.state.txt = e.target.value，要通过this.setState({txt: e.target.value})方式来改变state中的值","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react的jsx文件一般写法","slug":"react的jsx文件一般写法","date":"2018-03-21T02:23:48.000Z","updated":"2018-03-22T08:45:13.000Z","comments":true,"path":"2018/03/21/react的jsx文件一般写法/","link":"","permalink":"http://yoursite.com/2018/03/21/react的jsx文件一般写法/","excerpt":"","text":"12345678910111213141516171819202122import React , &#123; Component &#125; from 'react';clase Demo extends Component &#123; state = &#123; txt: 'hello man' &#125; handClick = () =&gt; &#123; // 事件 // todo something &#125; render() &#123; const &#123; txt &#125; = this.state; return ( &lt;div className=\"demo\" onClick=&#123;this.handClick&#125;&gt;&#123;txt&#125;&lt;/div&gt; ) &#125;&#125;;export default Demo;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"vscode 设置","slug":"vscode设置","date":"2018-03-19T03:11:24.000Z","updated":"2018-03-21T02:09:46.184Z","comments":true,"path":"2018/03/19/vscode设置/","link":"","permalink":"http://yoursite.com/2018/03/19/vscode设置/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 将设置放入此文件中以覆盖默认设置&#123; \"editor.tabSize\": 2, \"files.associations\": &#123; \"*.vue\": \"vue\" &#125;, \"eslint.autoFixOnSave\": true, \"eslint.options\": &#123; \"extensions\": [ \".js\", \".vue\" ] &#125;, \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"vue\", \"vue-html\" ], \"search.exclude\": &#123; \"**/node_modules\": true, \"**/bower_components\": true, \"**/dist\": true &#125;, \"emmet.syntaxProfiles\": &#123; \"javascript\": \"jsx\", \"vue\": \"html\", \"vue-html\": \"html\" &#125;, \"git.confirmSync\": false, \"window.zoomLevel\": -1, \"vsicons.projectDetection.autoReload\": true, \"typescript.check.tscVersion\": false, \"editor.renderWhitespace\": \"boundary\", \"editor.cursorBlinking\": \"smooth\", \"workbench.iconTheme\": \"vscode-icons\", \"editor.minimap.enabled\": true, \"editor.minimap.renderCharacters\": false, \"tslint.autoFixOnSave\": true, \"beautify.tabSize\": 2, \"window.title\": \"$&#123;dirty&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;rootName&#125;\", \"typescript.extension.sortImports.maxNamedImportsInSingleLine\": 5, \"typescript.extension.sortImports.omitSemicolon\": true, \"editor.codeLens\": true, \"editor.snippetSuggestions\": \"top\", \"react-native-storybooks.port\": 6006, \"sublimeTextKeymap.promptV3Features\": true, \"editor.multiCursorModifier\": \"ctrlCmd\", \"editor.formatOnPaste\": true, \"explorer.confirmDelete\": false&#125;","categories":[{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/categories/编辑器/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"mac下配置apache","slug":"mac下配置apache","date":"2018-03-14T05:57:40.000Z","updated":"2018-03-21T02:09:22.844Z","comments":true,"path":"2018/03/14/mac下配置apache/","link":"","permalink":"http://yoursite.com/2018/03/14/mac下配置apache/","excerpt":"","text":"mac下的apache的配置文件目录1/etc/apache2/httpd.conf 开启apache服务1sudo apachectl start 重启1$ sudo apachectl restart 停用1$ sudo apachectl stop","categories":[{"name":"服务器相关","slug":"服务器相关","permalink":"http://yoursite.com/categories/服务器相关/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"linux简单命令","slug":"linux简单命令","date":"2018-03-13T07:39:40.000Z","updated":"2018-03-21T02:09:14.000Z","comments":true,"path":"2018/03/13/linux简单命令/","link":"","permalink":"http://yoursite.com/2018/03/13/linux简单命令/","excerpt":"","text":"连接服务器1$ ssh root@ip 压缩文件1$ zip aaa.zip -d ./ 压缩当前文件夹下的所有文件1$ zip a.zip ./* 上传命令1$ scp ./build.zip root@123.207.22.89:/usr/local/openresty/nginx/html 解压文件12$ unzip aaa.zip -d ./ './' 表示当前文件夹 新建文件夹1$ mkdir 文件夹名称 删除文件1$ rm -f * 删除文件夹1$ rm -rf * 移动文件1$ mv 要移动的文件 -d 目标文件","categories":[{"name":"服务器相关","slug":"服务器相关","permalink":"http://yoursite.com/categories/服务器相关/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"zsh一些常用命令","slug":"zsh","date":"2018-03-13T07:39:40.000Z","updated":"2018-03-21T02:11:22.000Z","comments":true,"path":"2018/03/13/zsh/","link":"","permalink":"http://yoursite.com/2018/03/13/zsh/","excerpt":"","text":"插入1在vim中直接输入 `i` 保存并退出12$ ctrl+c $ 两个大写的ZZ 退出123$ ctrl+c $ :quit!$ 回车键","categories":[{"name":"zsh","slug":"zsh","permalink":"http://yoursite.com/categories/zsh/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}]},{"title":"vim一些常用命令","slug":"vim编辑文件","date":"2018-03-13T07:39:40.000Z","updated":"2018-03-21T02:09:33.672Z","comments":true,"path":"2018/03/13/vim编辑文件/","link":"","permalink":"http://yoursite.com/2018/03/13/vim编辑文件/","excerpt":"","text":"插入1在vim中直接输入 `i` 保存并退出12$ ctrl+c $ 两个大写的ZZ 退出123$ ctrl+c $ :quit!$ 回车键","categories":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}]},{"title":"hexo一些简单语法","slug":"hexo一些简单语法","date":"2018-03-13T04:00:24.000Z","updated":"2018-03-21T02:13:34.000Z","comments":true,"path":"2018/03/13/hexo一些简单语法/","link":"","permalink":"http://yoursite.com/2018/03/13/hexo一些简单语法/","excerpt":"","text":"环境 node git 选一个hexo主题 ps: 我用的是next那个主题 配置 如何分类？ 如何添加自己的样式？ 如何添加图片？ 一些简单markdown语法 加链接 1$ [jeff]('https://nieying.github.io') 图片 1$ ![test](/images/test.jpeg) 命令 hexo s hexo g hexo d hexo d -g","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"为什么React的性能要好","slug":"为什么React的性能要好","date":"2018-03-12T07:17:24.000Z","updated":"2018-03-21T02:08:48.215Z","comments":true,"path":"2018/03/12/为什么React的性能要好/","link":"","permalink":"http://yoursite.com/2018/03/12/为什么React的性能要好/","excerpt":"","text":"因为React做了俩点优化。 1、在渲染时性能的优化 React是创建了一个虚拟dom，这个dom不是真正页面中的dom元素，它实质上是一个js对象，用js对象存储dom上的信息，因此比真是的dom小得多，因为他只记录的一些必要的信息。 操作一个虚拟dom需要的性能要远小于操作一个真实dom的性能，在前端开发一个web应用与开发一个网站不同，web应用通常是一个单页面，因此每次做一些交互会涉及各种dom操作，因此无节制的操作dom严重影响了页面的性能，但是我们只是操作虚拟dom会很好的降低对性能的消耗，在必要的时候将视图渲染到页面之中。 2、在开发时的优化 React的开发理念是创建一个虚拟dom，而虚拟dom是一个js对象，它不是基于某一个端，比如真实的dom可能需要浏览器环境，它是基于web端的，所有通过React开发出来的组件可以用于任何平台，比如，服务器端，web端，ios端，android端将虚拟dom引用到不同的端上需要不同的插件，然后调用不同的render方法。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}]}