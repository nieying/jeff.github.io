{"meta":{"title":"长不大的孩子","subtitle":null,"description":"null==undefined","author":"jeff","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-03-12T09:48:53.000Z","updated":"2018-03-21T02:05:25.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-03-12T09:50:47.000Z","updated":"2018-03-21T02:05:15.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-03-13T06:19:11.000Z","updated":"2018-03-21T02:05:02.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js部分概念","slug":"js概念宝典","date":"2018-07-11T01:38:54.000Z","updated":"2018-07-13T06:49:38.543Z","comments":true,"path":"2018/07/11/js概念宝典/","link":"","permalink":"http://yoursite.com/2018/07/11/js概念宝典/","excerpt":"","text":"JS 的垃圾回收机制12* Js具有自动垃圾回收机制。垃圾收集器会按照固定的时间间隔周期性的执行。* JS中最常见的垃圾回收方式是标记清除。` 工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。工作流程： 1234垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。去掉环境中的变量以及被环境中的变量引用的变量的标记。再被加上标记的会被视为准备删除的变量。垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 引用计数工作原理：跟踪记录每个值被引用的次数。 工作流程： 12345声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.当引用次数变成0时，说明没办法访问这个值了。当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 但是循环引用的时候就会释放不掉内存。循环引用就是对象 A 中包含另一个指向对象 B 的指针，B 中也包含一个指向 A 的引用。因为 IE 中的 BOM、DOM 的实现使用了 COM，而 COM 对象使用的垃圾收集机制是引用计数策略。所以会存在循环引用的问题。解决：手工断开 js 对象和 DOM 之间的链接。赋值为 null。IE9 把 DOM 和 BOM 转换成真正的 JS 对象了，所以避免了这个问题。 什么情况会引起内存泄漏？虽然有垃圾回收机制但是我们编写代码操作不当还是会造成内存泄漏。 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。解决：使用严格模式避免。 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对 dom 的引用。 没有清理的 DOM 元素引用 原因：虽然别的地方删除了，但是对象中还存在对 dom 的引用解决：手动删除。 被遗忘的定时器或者回调 原因：定时器中有 dom 的引用，即使 dom 删除了，但是定时器还在，所以内存中还是有这个 dom。解决：手动删除定时器和 dom。 子元素存在引用引起的内存泄漏 原因：div 中的 ul li 得到这个 div，会间接引用某个得到的 li，那么此时因为 div 间接引用 li，即使 li 被清空，也还是在内存中，并且只要 li 不被删除，他的父元素都不会被删除。解决：手动删除清空。 什么放在内存中？什么不放在内存中？基本类型是：Undefined/Null/Boolean/Number/String 基本类型的值存在内存中，被保存在栈内存中。从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。 引用类型：object 引用类型的值是对象，保存在堆内存中。 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。 js 不允许直接访问内存中的位置，也就是不能直接访问操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。 栈和堆的区别一、堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 2、堆（操作系统）： 一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。 二、堆栈缓存方式区别： 1、栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放； 2、堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 三、堆栈数据结构区别： 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 浏览器输入URL过程中都发生了什么？详细版浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;进行HTTP协议会话，客户端发送报头(请求报头);进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；载入解析到的资源文件，渲染页面，完成。 HTTPS认证服务器。浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。 协商会话密钥。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。 加密通讯。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。 HTTPS和HTTP的区别超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTPS和HTTP的区别主要为以下四点：1234https协议需要到ca申请证书，一般免费证书很少，需要交费。http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTP状态码100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 null和undefined区别null是一个表示&quot;无&quot;的对象，转为数值时为0；undefined是一个表示&quot;无&quot;的原始值，转为数值时为NaN null作为函数参数，表示该函数参数不是对象；作为对象原型链的终点 undefined变量被申明了，但是没有被赋值，就等于undefined;调用函数时，应该提供的参数没有提供，该参数等于undefined。对象没有赋值的属性，该属性的值为undefined。函数没有返回值时，默认返回undefined。","categories":[{"name":"theory","slug":"theory","permalink":"http://yoursite.com/categories/theory/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"call与apply区别","slug":"call与apply区别","date":"2018-06-28T00:38:54.000Z","updated":"2018-06-28T12:35:07.796Z","comments":true,"path":"2018/06/28/call与apply区别/","link":"","permalink":"http://yoursite.com/2018/06/28/call与apply区别/","excerpt":"","text":"区别 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。 相同点：这两个方法的作用是一样的。都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。 call()方法使用12345678910111213&lt;script&gt; window.color = 'red'; document.color = 'yellow'; var s1 = &#123;color: 'blue' &#125;; function changeColor()&#123; console.log(this.color); &#125; changeColor.call(); //red (默认传递参数) changeColor.call(window); //red changeColor.call(document); //yellow changeColor.call(this); //red changeColor.call(s1); //blue&lt;/script&gt; 1234567891011121314var Pet = &#123; words : '...', speak : function (say) &#123; console.log(say + ''+ this.words) &#125;&#125;Pet.speak('Speak'); // 结果：Speak...var Dog = &#123; words:'Wang'&#125;//将this的指向改变成了DogPet.speak.call(Dog, 'Speak'); //结果： SpeakWang apply()方法使用1234567891011121314&lt;script&gt; window.number = 'one'; document.number = 'two'; var s1 = &#123;number: 'three' &#125;; function changeColor()&#123; console.log(this.number); &#125; changeColor.apply(); //one (默认传参) changeColor.apply(window); //one changeColor.apply(document); //two changeColor.apply(this); //one changeColor.apply(s1); //three&lt;/script&gt; 123456789101112function Pet(words)&#123; this.words = words; this.speak = function () &#123; console.log( this.words) &#125;&#125;function Dog(words)&#123; //Pet.call(this, words); //结果： Wang Pet.apply(this, arguments); //结果： Wang&#125;var dog = new Dog('Wang');dog.speak();","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"css宝典","slug":"css宝典","date":"2018-06-27T23:38:54.000Z","updated":"2018-07-11T02:22:43.346Z","comments":true,"path":"2018/06/28/css宝典/","link":"","permalink":"http://yoursite.com/2018/06/28/css宝典/","excerpt":"","text":"兼容IE多行…显示12345678910111213.class &#123; position: relative; overflow: hidden; max-height: 40px; &amp;::after &#123; content: '...'; position: absolute; right: 0; bottom: 0; padding-left: 10px; backgroud: linear-gradient(left, transparent, #fff 50%); &#125;&#125; 只在谷歌浏览器有效果123456789.a &#123; overflow: hidden; text-overflow: ellipsis; word-break: break-all; display: -webkit-box; -webkit-box-orient: vertical; //要显示的行数 -webkit-line-clamp: 2;&#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"h5兼容问题","slug":"h5兼容问题","date":"2018-06-26T01:28:54.000Z","updated":"2018-06-26T01:32:35.978Z","comments":true,"path":"2018/06/26/h5兼容问题/","link":"","permalink":"http://yoursite.com/2018/06/26/h5兼容问题/","excerpt":"","text":"1)写背景图时最好加上top left 或者0 0 不然写运动效果时容易出现跳2)防止手机中网页放大和缩小:&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=0&quot; /&gt;3)设置Web应用是否以全屏模式运行:&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;,content的默认值是no 4)自动识别电话号码:&lt;meta name=&quot;format-detection&quot; ontent=&quot;telephone=no&quot;&gt;,telephone=no可以禁用这功能,默认值是no 5)禁止复制、选中文本: 123456Element &#123; -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none;&#125; 7) 设置缓存:&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt;手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 8) 苹果手机固定定位有bug 检查html和body是不是设置了overflow-x:hidden; 9) IOS手机中如果出现一个元素的层级非常高可还是被别的元素遮盖的，那么就将该元素与别的元素同级 10) 给不同屏幕大小的手机设置特殊样式:@media only screen and (min-device-width : 320px) and (max-device-width : 375px){ } 11) IOS中input键盘事件keyup、keydown、keypress支持不是很好, 用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中用输入法输入之后，并未立刻相应keyup事件，只有在通过删除之后才可以响应方法：可以用html5的oninput事件去代替keyup 123456&lt;input type=\"text\" id=\"testInput\"&gt;&lt;script type=\"text/javascript\"&gt; document.getElementById('input').addEventListener('input', function(e)&#123; var value = e.target.value; &#125;);&lt;/script&gt; 12)、ios 设置input 按钮样式会被默认样式覆盖解决方式如下：12345input,textarea &#123; border: 0; -webkit-appearance: none;&#125; 13)、消除 IE10 里面的那个叉号:input:-ms-clear{display:none;} 14)、关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格可以通过正则去掉1this.value = this.value.replace(/\\u2006/g, ‘’);15)、手机上的flex布局时会有兼容性问题，只用新版本的会出现安卓手机不识别的现象1234567891011121314.box&#123; display: -webkit-box; /* 老版本语法: Safari, iOS, Android browser, older WebKit browsers. */ display: -moz-box; /* 老版本语法: Firefox (buggy) */ display: -ms-flexbox; /* 混合版本语法: IE 10 */ display: -webkit-flex; /* 新版本语法: Chrome 21+ */display: flex; /* 新版本语法: Opera 12.1, Firefox 22+ */&#125;.box&gt;li&#123;-webkit-box-flex: 1.0;box-flex: 1.0;-webkit-flex: 1.0;flex: 1;width: 0;/*解决兼容性问题*/&#125; 16)、123456html,body&#123;overflow: hidden;/*手机上写overflow-x:hidden;会有兼容性问题，如果子级如果是绝对定位有运动到屏幕外的话ios7系统会出现留白*/-webkit-overflow-scrolling:touch;/*流畅滚动,ios7下会有滑一下滑不动的情况，所以需要写上*/position:realtive;/*直接子级如果是绝对定位有运动到屏幕外的话，会出现留白*/&#125; 17)viewport模板123456&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;//主要I是强制让文档的宽度与设备宽度保持1:1，最大宽度1.0，禁止屏幕缩放。&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt;//这个也是iphone私有标签，允许全屏浏览。&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt;//iphone的私有标签，iphone顶端状态条的样式。&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;//禁止数字自动识别为电话号码，这个比较有用，因为一串数字在iphone上会显示成蓝色，样式加成别的颜色也是不生效的。&lt;meta content=\"email=no\" name=\"format-detection\"&gt;","categories":[],"tags":[{"name":"h5","slug":"h5","permalink":"http://yoursite.com/tags/h5/"}]},{"title":"js常用方法","slug":"js常用方法","date":"2018-05-16T02:18:54.000Z","updated":"2018-07-13T06:31:16.124Z","comments":true,"path":"2018/05/16/js常用方法/","link":"","permalink":"http://yoursite.com/2018/05/16/js常用方法/","excerpt":"","text":"js去除字符串空格1.使用replace正则匹配的方法1234去除所有空格: str = str.replace(/\\s*/g,&quot;&quot;); 去除两头空格: str = str.replace(/^\\s*|\\s*$/g,&quot;&quot;);去除左空格： str = str.replace( /^\\s*/, “”);去除右空格： str = str.replace(/(\\s*$)/g, &quot;&quot;); 2.使用str.trim()方法123var str = \" xiao ming \";var str2 = str.trim();console.log(str2); //xiao ming 同理，str.trimLeft()，str.trimRight()分别用于去除字符串左右空格。 数组去重1.传统方法12345678910var arr = [0,2,3,4,4,0,2];var obj = &#123;&#125;;var tmp = [];for(var i = 0 ;i&lt; arr.length; i++)&#123; if( !obj[arr[i]] )&#123; obj[arr[i]] = 1; tmp.push(arr[i]); &#125;&#125;console.log(tmp); // [0,2,3,4] 2.通过indexOf方法来实现12345678var arr = [2,3,4,4,5,2,3,6], arr2 = [];for(var i = 0;i&lt; arr.length;i++)&#123; if(arr2.indexOf(arr[i]) &lt; 0)&#123; arr2.push(arr[i]); &#125;&#125;console.log(arr2); 3.通过filter方法来实现12345var arr = [2,3,4,4,5,2,3,6];var arr2 = arr.filter(function(element,index,self)&#123;return self.indexOf(element) === index;&#125;);console.log(arr2); js判断是否为谷歌浏览器1navigator.userAgent.indexOf('Chrome') === -1 浏览器兼容ToFixed(保留两位小数)1234567891011121314export function fmoney(num, decimal = 4) &#123; if (num === 0 || !num) &#123; return 0 &#125; const times = Math.pow(10, decimal + 1), des = parseInt(num * times), rest = des % 10 if (rest === 5) &#123; return ((parseFloat(des) + 1) / times).toFixed(decimal) &#125; else if (rest === -5) &#123; return ((parseFloat(des) - 1) / times).toFixed(decimal) &#125; return num.toFixed(decimal)&#125; 过滤html代码 （这里是过滤html中的img标签）1234567891011121314export function filterEditor(html) &#123; return html.replace(/&lt;\\s?img[^&gt;]*&gt;/gi, '[图片]').replace(/&lt;(?:.|\\s)*?&gt;/g, '').replace(/&lt;\\s?br[^&gt;]*/gi, ' ')&#125;``` #### 如何将浮点数点左边的数每三位添加一个逗号```bash function commafy(num)&#123; return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d&#123;3&#125;)+\\.)/g, function($1, $2)&#123; return $2 + ','; &#125;); &#125; JS深度复制12345678910111213141516171819function deepClone(obj) &#123; var result,objType = Object.prototype.toString.call(obj).slice(8,-1); if (objType === 'Object') &#123; result = &#123;&#125;; &#125; else if (objType === 'Array') &#123; result = []; &#125; else &#123; return obj; &#125; for (key in obj) &#123; var copy = obj[key]; if (objType === 'Object' || objType === 'Array') &#123; result[key] = arguments.callee(copy); &#125; else &#123; result[key] = obj[key] &#125; &#125; return result;&#125;","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"react-生命周期函数","slug":"react-生命周期函数","date":"2018-05-09T05:47:14.000Z","updated":"2018-05-09T06:33:34.000Z","comments":true,"path":"2018/05/09/react-生命周期函数/","link":"","permalink":"http://yoursite.com/2018/05/09/react-生命周期函数/","excerpt":"","text":"组件的生命周期可分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM componentWillMount在渲染前调用，在客户端也在服务端 componentDidMount在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。 componentWillReceiveProps在组建接收到一个新的props（跟新后）调用。在初始化render的时候不会被调用 shouldComponentUpdate返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。 componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。 componentDidUpdate在组件完成更新后立即调用。在初始化时不会被调用。 componentWillUnmount在组件从DOM中移除的时刻立即被调用 下面是一个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Button = React.createClass(&#123; getInitialState: function() &#123; return &#123; data:0 &#125;; &#125;, setNewNumber: function() &#123; this.setState(&#123;data: this.state.data + 1&#125;) &#125;, render: function () &#123; return ( &lt;div&gt; &lt;button onClick = &#123;this.setNewNumber&#125;&gt;INCREMENT&lt;/button&gt; &lt;Content myNumber = &#123;this.state.data&#125;&gt;&lt;/Content&gt; &lt;/div&gt; ); &#125;&#125;)var Content = React.createClass(&#123; componentWillMount() &#123; console.log('Component WILL MOUNT!') &#125;, componentDidMount() &#123; console.log('Component DID MOUNT!') &#125;, componentWillReceiveProps(newProps) &#123; console.log('Component WILL RECEIVE PROPS!') &#125;, shouldComponentUpdate(newProps, newState) &#123; return true; &#125;, componentWillUpdate(nextProps, nextState) &#123; console.log('Component WILL UPDATE!'); &#125;, componentDidUpdate(prevProps, prevState) &#123; console.log('Component DID UPDATE!') &#125;, componentWillUnmount() &#123; console.log('Component WILL UNMOUNT!') &#125;, render: function () &#123; return ( &lt;div&gt; &lt;h3&gt;&#123;this.props.myNumber&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;div&gt; &lt;Button /&gt; &lt;/div&gt;, document.getElementById('example'));","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-redux简单用法","slug":"react-redux简单用法","date":"2018-05-08T07:43:49.000Z","updated":"2018-05-08T08:24:01.964Z","comments":true,"path":"2018/05/08/react-redux简单用法/","link":"","permalink":"http://yoursite.com/2018/05/08/react-redux简单用法/","excerpt":"","text":"React-redux简介React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件（container component）。 UI组件 只负责 UI 的呈现，不带有任何业务逻辑 没有状态（即不使用this.state这个变量） 所有数据都由参数（this.props）提供 不使用任何 Redux 的 API 容器组件 负责管理数据和业务逻辑，不负责 UI 的呈现 带有内部状态 使用 Redux 的 API connect就是把UI组件和容器组件连接起来 mapStateToPropsmapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。12345const mapStateToProps = (state) =&gt; &#123; return &#123; userInfo: state.global.userInfo &#125;&#125; 使用redux无论代码怎么布局，使用redux的方法主要还是三步曲：创建store、创建action、创建reducer。而在这之后才是与业务或者组件相关的数据处理和展示。 App.js // 入口文件 123456789101112131415161718import React from 'react';import ReactDOM from 'react-dom';import &#123; createStore, applyMiddleware, combineReducers &#125; from 'redux';import thunk form 'redux-thunk';import &#123; Provider &#125; from 'react-redux'import rootReducer from '../../index'const store = createStore( combineReducers(&#123; ...rootReducer &#125;), applyMiddleware(thunk));ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;div &#123;this.props&#125; /&gt; &lt;/Provider&gt; , document.getElementById('root')) index.js // 所有的reducer入口 1234567import &#123;global&#125; from './global'const rootReducer = &#123; global&#125;export default rootReducer action 1234export const saveUserInfo = userInfo =&gt; (&#123; type:'SAVE_USER_INFO', userInfo&#125;) reducers 12345678910111213export const global = (state, action) =&gt; &#123; switch(action.type) &#123; case 'SAVE_USER_INFO': return &#123; ...state, userInfo: action.userInfo &#125;; default: return state; &#125;&#125; 组件中使用 123456789101112131415161718import &#123; connent &#125; from 'redux'import &#123; saveUserInfo &#125; from '../action.js'class Login extends Component &#123; onClickCallback = () =&gt; &#123; this.props.dispath(saveUserInfo(data)) // 触发action &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; userInfo: state.global.userInfo &#125;&#125;export default connect(mapStateToProps)(Login)","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-ref用法","slug":"react-ref用法","date":"2018-05-08T07:29:54.000Z","updated":"2018-05-08T07:39:34.000Z","comments":true,"path":"2018/05/08/react-ref用法/","link":"","permalink":"http://yoursite.com/2018/05/08/react-ref用法/","excerpt":"","text":"ref定义ref顾名思义我们知道，其实它就可以被看座是一个组件的参考，也可以说是一个标识。作为组件的属性，其属性值可以是一个字符串也可以是一个函数。 ref使用场景父类调用子类的方法 1234567891011121314151617181920212223242526class Parents extends Component &#123; sayHello = () =&gt; &#123; this.refs.fun() // 调用子类方法 &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.sayHello&#125;&gt;click me&lt;/button&gt; &lt;Childs ref=&#123;(ref) =&gt; &#123;this.refs = ref;&#125;&#125;/&gt; &lt;/div&gt; ) &#125;&#125;class Childs extends Component &#123; fun = () =&gt; &#123; console.log('hello boys') &#125; render () &#123; return ( &lt;div&gt; hello &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"vue-router-导航钩子","slug":"vue-router-导航钩子","date":"2018-05-07T06:13:44.000Z","updated":"2018-05-14T08:02:50.000Z","comments":true,"path":"2018/05/07/vue-router-导航钩子/","link":"","permalink":"http://yoursite.com/2018/05/07/vue-router-导航钩子/","excerpt":"","text":"全局钩子123456789101112// 定义一个路由const router = new VueRouter(&#123;&#125;)// 点击路由前调用router.beforeEach((to, from, next) =&gt; &#123; // todo&#125;)// 点击路由后调用router.afterEach((to, from , next) =&gt; &#123; // tood&#125;) to 即将进入的目标，路有对象 from 当前正要离开的路由 next Function 一定要调用该方法来resolve这个钩子，执行效果依赖next方法的调用参数 单个路由独享的钩子1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/test', component: Test, beforeEnter: (to, from, next) =&gt; &#123; // todo &#125;, beforeEnter: (route) =&gt; &#123; // todo &#125; &#125; ]&#125;); 组件内的钩子123456789101112131415const Foo = &#123; tempalte: `...`, beforeRouteEnter(to, from , next) &#123; // 不能访问组件实例 `this`, 因为在这个时候组件还没被创建，但是可以通过 `next` 来访问 next (vm = &gt; &#123; // 通过 `vm` 访问组件实例 &#125;) &#125;, beforeRouteUpdate(to, from , next) &#123; // todo &#125;, beforeRouteLeave(to, from , next) &#123; // todo &#125;,&#125;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"react监听路有变化","slug":"react监听路有变化","date":"2018-03-30T01:09:33.000Z","updated":"2018-05-07T06:14:50.542Z","comments":true,"path":"2018/03/30/react监听路有变化/","link":"","permalink":"http://yoursite.com/2018/03/30/react监听路有变化/","excerpt":"","text":"12345678910111213141516171819202122import React , &#123; Component &#125; from 'react';import creactHistory from 'history/createHashHistory'const history = createHistory();clase Demo extends Component &#123; componentDidMount() &#123; this.listenHistory() &#125; listenHistory = () =&gt; &#123; history.listen((location) =&gt; &#123; // todo something &#125;) &#125;&#125;;export default Demo;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react定时器","slug":"react定时器","date":"2018-03-22T09:16:02.000Z","updated":"2018-05-07T06:15:27.000Z","comments":true,"path":"2018/03/22/react定时器/","link":"","permalink":"http://yoursite.com/2018/03/22/react定时器/","excerpt":"","text":"123456789101112131415import React , &#123; Component &#125; from 'react';clase Demo extends Component &#123; hanldClick = () =&gt; &#123; this.timer &amp;&amp; clearInterval(this.timer) this.timer = setInterval(() =&gt; &#123; // todo something &#125;, 1000) &#125; &#125;;export default Demo;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react如何实现双向绑定的？","slug":"react如何实现双向绑定的？","date":"2018-03-21T02:31:30.000Z","updated":"2018-05-07T06:15:12.605Z","comments":true,"path":"2018/03/21/react如何实现双向绑定的？/","link":"","permalink":"http://yoursite.com/2018/03/21/react如何实现双向绑定的？/","excerpt":"","text":"大家都知道react是单向数据流的，那我们怎么实现数据双向绑定的呢？ 12345678910111213141516171819202122232425import React , &#123; Component &#125; from 'react';clase Demo extends Component &#123; state = &#123; txt: 'hello man' &#125; handChange = (e) =&gt; &#123; console.log(e.target) this.setState(&#123;txt: e.target.value&#125;) // todo something &#125; render() &#123; const &#123; txt &#125; = this.state; return ( &lt;input type=\"text\" value=&#123;txt&#125; onChange=&#123;this.handChange&#125;/&gt; &lt;p&gt;&#123;txt&#125;&lt;/p&gt; ) &#125;&#125;;export default Demo; 记住在react中改变state中值，千万不要直接 this.state.txt = e.target.value，要通过this.setState({txt: e.target.value})方式来改变state中的值","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react的jsx文件一般写法","slug":"react的jsx文件一般写法","date":"2018-03-21T02:23:48.000Z","updated":"2018-03-22T08:45:13.000Z","comments":true,"path":"2018/03/21/react的jsx文件一般写法/","link":"","permalink":"http://yoursite.com/2018/03/21/react的jsx文件一般写法/","excerpt":"","text":"12345678910111213141516171819202122import React , &#123; Component &#125; from 'react';clase Demo extends Component &#123; state = &#123; txt: 'hello man' &#125; handClick = () =&gt; &#123; // 事件 // todo something &#125; render() &#123; const &#123; txt &#125; = this.state; return ( &lt;div className=\"demo\" onClick=&#123;this.handClick&#125;&gt;&#123;txt&#125;&lt;/div&gt; ) &#125;&#125;;export default Demo;","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"vscode 设置","slug":"vscode设置","date":"2018-03-19T03:11:24.000Z","updated":"2018-03-21T02:09:46.184Z","comments":true,"path":"2018/03/19/vscode设置/","link":"","permalink":"http://yoursite.com/2018/03/19/vscode设置/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 将设置放入此文件中以覆盖默认设置&#123; \"editor.tabSize\": 2, \"files.associations\": &#123; \"*.vue\": \"vue\" &#125;, \"eslint.autoFixOnSave\": true, \"eslint.options\": &#123; \"extensions\": [ \".js\", \".vue\" ] &#125;, \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"vue\", \"vue-html\" ], \"search.exclude\": &#123; \"**/node_modules\": true, \"**/bower_components\": true, \"**/dist\": true &#125;, \"emmet.syntaxProfiles\": &#123; \"javascript\": \"jsx\", \"vue\": \"html\", \"vue-html\": \"html\" &#125;, \"git.confirmSync\": false, \"window.zoomLevel\": -1, \"vsicons.projectDetection.autoReload\": true, \"typescript.check.tscVersion\": false, \"editor.renderWhitespace\": \"boundary\", \"editor.cursorBlinking\": \"smooth\", \"workbench.iconTheme\": \"vscode-icons\", \"editor.minimap.enabled\": true, \"editor.minimap.renderCharacters\": false, \"tslint.autoFixOnSave\": true, \"beautify.tabSize\": 2, \"window.title\": \"$&#123;dirty&#125;$&#123;activeEditorMedium&#125;$&#123;separator&#125;$&#123;rootName&#125;\", \"typescript.extension.sortImports.maxNamedImportsInSingleLine\": 5, \"typescript.extension.sortImports.omitSemicolon\": true, \"editor.codeLens\": true, \"editor.snippetSuggestions\": \"top\", \"react-native-storybooks.port\": 6006, \"sublimeTextKeymap.promptV3Features\": true, \"editor.multiCursorModifier\": \"ctrlCmd\", \"editor.formatOnPaste\": true, \"explorer.confirmDelete\": false&#125;","categories":[{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/categories/编辑器/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"mac下配置apache","slug":"mac下配置apache","date":"2018-03-14T05:57:40.000Z","updated":"2018-03-21T02:09:22.844Z","comments":true,"path":"2018/03/14/mac下配置apache/","link":"","permalink":"http://yoursite.com/2018/03/14/mac下配置apache/","excerpt":"","text":"mac下的apache的配置文件目录1/etc/apache2/httpd.conf 开启apache服务1sudo apachectl start 重启1$ sudo apachectl restart 停用1$ sudo apachectl stop","categories":[{"name":"服务器相关","slug":"服务器相关","permalink":"http://yoursite.com/categories/服务器相关/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"vim一些常用命令","slug":"vim编辑文件","date":"2018-03-13T07:39:40.000Z","updated":"2018-03-21T02:09:33.672Z","comments":true,"path":"2018/03/13/vim编辑文件/","link":"","permalink":"http://yoursite.com/2018/03/13/vim编辑文件/","excerpt":"","text":"插入1在vim中直接输入 `i` 保存并退出12$ ctrl+c $ 两个大写的ZZ 退出123$ ctrl+c $ :quit!$ 回车键","categories":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/categories/vim/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}]},{"title":"zsh一些常用命令","slug":"zsh","date":"2018-03-13T07:39:40.000Z","updated":"2018-03-21T02:11:22.000Z","comments":true,"path":"2018/03/13/zsh/","link":"","permalink":"http://yoursite.com/2018/03/13/zsh/","excerpt":"","text":"插入1在vim中直接输入 `i` 保存并退出12$ ctrl+c $ 两个大写的ZZ 退出123$ ctrl+c $ :quit!$ 回车键","categories":[{"name":"zsh","slug":"zsh","permalink":"http://yoursite.com/categories/zsh/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}]},{"title":"linux简单命令","slug":"linux简单命令","date":"2018-03-13T07:39:40.000Z","updated":"2018-03-21T02:09:14.000Z","comments":true,"path":"2018/03/13/linux简单命令/","link":"","permalink":"http://yoursite.com/2018/03/13/linux简单命令/","excerpt":"","text":"连接服务器1$ ssh root@ip 压缩文件1$ zip aaa.zip -d ./ 压缩当前文件夹下的所有文件1$ zip a.zip ./* 上传命令1$ scp ./build.zip root@123.207.22.89:/usr/local/openresty/nginx/html 解压文件12$ unzip aaa.zip -d ./ './' 表示当前文件夹 新建文件夹1$ mkdir 文件夹名称 删除文件1$ rm -f * 删除文件夹1$ rm -rf * 移动文件1$ mv 要移动的文件 -d 目标文件","categories":[{"name":"服务器相关","slug":"服务器相关","permalink":"http://yoursite.com/categories/服务器相关/"}],"tags":[{"name":"server","slug":"server","permalink":"http://yoursite.com/tags/server/"}]},{"title":"hexo一些简单语法","slug":"hexo一些简单语法","date":"2018-03-13T04:00:24.000Z","updated":"2018-03-21T02:13:34.000Z","comments":true,"path":"2018/03/13/hexo一些简单语法/","link":"","permalink":"http://yoursite.com/2018/03/13/hexo一些简单语法/","excerpt":"","text":"环境 node git 选一个hexo主题 ps: 我用的是next那个主题 配置 如何分类？ 如何添加自己的样式？ 如何添加图片？ 一些简单markdown语法 加链接 1$ [jeff]('https://nieying.github.io') 图片 1$ ![test](/images/test.jpeg) 命令 hexo s hexo g hexo d hexo d -g","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"为什么React的性能要好","slug":"为什么React的性能要好","date":"2018-03-12T07:17:24.000Z","updated":"2018-03-21T02:08:48.215Z","comments":true,"path":"2018/03/12/为什么React的性能要好/","link":"","permalink":"http://yoursite.com/2018/03/12/为什么React的性能要好/","excerpt":"","text":"因为React做了俩点优化。 1、在渲染时性能的优化 React是创建了一个虚拟dom，这个dom不是真正页面中的dom元素，它实质上是一个js对象，用js对象存储dom上的信息，因此比真是的dom小得多，因为他只记录的一些必要的信息。 操作一个虚拟dom需要的性能要远小于操作一个真实dom的性能，在前端开发一个web应用与开发一个网站不同，web应用通常是一个单页面，因此每次做一些交互会涉及各种dom操作，因此无节制的操作dom严重影响了页面的性能，但是我们只是操作虚拟dom会很好的降低对性能的消耗，在必要的时候将视图渲染到页面之中。 2、在开发时的优化 React的开发理念是创建一个虚拟dom，而虚拟dom是一个js对象，它不是基于某一个端，比如真实的dom可能需要浏览器环境，它是基于web端的，所有通过React开发出来的组件可以用于任何平台，比如，服务器端，web端，ios端，android端将虚拟dom引用到不同的端上需要不同的插件，然后调用不同的render方法。","categories":[{"name":"前端框架","slug":"前端框架","permalink":"http://yoursite.com/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]}]}